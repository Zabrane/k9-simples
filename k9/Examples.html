<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- October 17, 2020

Copyright (C) 2020 John Estrada -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Examples (Shakti tutorial)</title>

<meta name="description" content="Examples (Shakti tutorial)">
<meta name="keywords" content="Examples (Shakti tutorial)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<link href="index.html" rel="start" title="Top">
<link href="index.html" rel="up" title="Top">
<link href="Benchmarks.html" rel="next" title="Benchmarks">
<link href="Intro.html" rel="prev" title="Intro">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Examples"></span><div class="header">
<p>
Next: <a href="Benchmarks.html" accesskey="n" rel="next">Benchmarks</a>, Previous: <a href="Intro.html" accesskey="p" rel="prev">Intro</a>, Up: <a href="index.html" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<hr>
<span id="Examples-1"></span><h2 class="chapter">2 Examples</h2>
<p>Before jumping into synax let&rsquo;s look at some example problems to get a sense of the speed of k9 at processing data.  Given both the historic use of languages similar to k9 in finance and the author&rsquo;s background much of the examples will be based on financial markets.  For those not familiar with this field a short introduction will likley be needed.
</p>
<span id="A-Tiny-Introduction-to-Financial-Market-Data"></span><h3 class="section">2.1 A Tiny Introduction to Financial Market Data</h3>
<p>Financial market data generally are stored as prices (often call quotes) and trades.  Prices will include at a minimum time, securtiy, price to buy and price to sell.  Trades will include at a minimum time, security, and trade price.  In normal markets there are many more prices than trades.
</p>
<p>Let&rsquo;s use k9 to generate a set of random prices for a single security hence elimating the need for that field.
</p>
<div class="example">
<pre class="example"> n:10
 T:10:00+`t n?36e5
 B:100++\-1+n?3
 A:B+1+n?2
 q:+`t`b`a!(T;B;A);q
t            b   a  
------------ --- ---
10:01:48.464 100 102
10:23:12.033 100 102
10:30:00.432 101 102
10:34:00.383 101 103
10:34:36.839 101 102
10:42:59.230 100 102
10:46:50.478 100 102
10:52:42.189  99 100
10:55:52.208  99 101
10:59:06.262  98  99
</pre></div>

<p>Here you see that at 10:42:59.230 the prices update to 100 and 102.  The price one could sell is 100 and the price to buy is 102.  You might think that 100 seems a bit high so sell there.  Later at 10:59:06.262 you might have thought the prices look low and then buy at 99.  Here&rsquo;s the trade table for those two transactions.
</p>
<div class="example">
<pre class="example"> t:+`t`p!(10:43:00.230 10:59:07.262:;100 99);t
t            p  
------------ ---
10:43:00.230 100
10:59:07.262  99
</pre></div>

<p>You&rsquo;ll note that the times didn&rsquo;t line up and that&rsquo;s because it apparently took you 1s to decide to trade.  Because of this delay you&rsquo;ll often have to look back at the previous prices to join trade (t) and quote (q) data.
</p>
<p>Now that you&rsquo;ve learned enough finance to understand the data, let&rsquo;s scale up to larger problems to see the power of k9.
</p>

<span id="Data-Manipulation"></span><h3 class="section">2.2 Data Manipulation</h3>
<p>Generate a table of random financial data and compute basic statistics quickly.  This table takes about 4 GB and 3.3 seconds on a relatively new consumer laptop.
</p>
<div class="example">
<pre class="example">&nbsp;n:_100e6                               / 100 million rows
&nbsp;t:{09:00:00.000+x?10:00:00.000}     / random times
&nbsp;s:{x?`a`b`c`d`e}                    / random symbols
&nbsp;m:0,(|m),365378984,m:271810244 42800467 2636454 62769 572 2;
&nbsp;d:{(-6+!13)@(+\m)bin x?_1e9}
&nbsp;\t q:+`t`s`d!(t[n];s[n];d[n])          / time data generation in ms
3391
</pre></div>

<p>As this point one might want to check start and stop times, see if the symbol distribution is actually random and look at the distribution of the price deltas.
</p>
<div class="example">
<pre class="example">&nbsp;select min t, max t from q        / min and max time values
t|09:00:00.000
t|18:59:59.999

&nbsp;select #s by s from q             / count each symbol
s|s       
-|--------
a|19999325
b|20000982
c|19996938
d|20001721
e|20001034

&nbsp;select #d by d from q             / check the normal distribution
d |d       
--|--------
-6|       1
-5|      46
-4|    6284
-3|  263124
-2| 4276881
-1|27184896
 0|36538226
 1|27182073
 2| 4278498
 3|  263523
 4|    6391
 5|      57
</pre></div>

<span id="Understanding-Code-Examples"></span><h3 class="section">2.3 Understanding Code Examples</h3>
<p>In the shakti mailing list there is a number of code examples that can be used to learn best practice.  In order to make sense of other&rsquo;s codes one needs to be able to effeciently parse the typically dense k9 language.  Here, an example of how one goes about this process is presented.
</p>
<div class="example">
<pre class="example">ss:{*{
      o:o@&amp;(-1+(#y)+*x@1)&lt;o:1_x@1;
      $[0&lt;#x@1;((x@0),*x@1;o);x]}[;y]/:(();&amp;(x@(!#x)+\!#y)~\y)
      }
</pre></div>

<p>This function finds a substring in a string.
</p>
<pre class="verbatim"> 000000000011111111112222222222333333
 012345678901234567890123456789012345
&quot;Find the +++ needle in + the ++ text&quot;
</pre>
<p>Here one would expect to find &ldquo;++&rdquo; at 9 and 29.
</p>
<div class="example">
<pre class="example">&nbsp;ss[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
9 29
</pre></div>

<p>In order to determine how this function works let&rsquo;s strip out the details...
</p>
<div class="example">
<pre class="example">ss:{
    *{
      o:o@&amp;(-1+(#y)+*x@1)&lt;o:1_x@1; / set o 
      $[0&lt;#x@1;((x@0),*x@1;o);x]   / if x then y else z
      }
  [;y]/:(();&amp;(x@(!#x)+\!#y)~\y)    / use value for inner function
  }
 
</pre></div>

<p>Given k9 evaluates right to left let&rsquo;s start with the right most code fragment.
</p>
<div class="example">
<pre class="example">&nbsp;(();&amp;(x@(!#x)+\!#y)~\y)          / a list (null;value)
</pre></div>

<p>And now let&rsquo;s focus on the value in the list.
</p>
<div class="example">
<pre class="example">&nbsp;&amp;(x@(!#x)+\!#y)~\y
</pre></div>

<p>In order to easily check our understand we can wrap this in a function and call the function with the parameters shown above.  In order to step through we can start with the inner parenthesis and build up the code until it is complete.
</p>
<div class="example">
<pre class="example">&nbsp;{!#x}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
{!#x}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
^
:rank
</pre></div>

<p>This won&rsquo;t work as one cannot call a function with two arguments and then only use one.  In order to get around this we will insert code for the second argument but not use it.
</p>
<div class="example">
<pre class="example"> {y;#x}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
36
 {y;!#x}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ..
</pre></div>

<p>As might have been guessed <code>#x</code> counts the number of charcters in the first argument and then <code>!#x</code> generates a list of integers from 0 to n-1.
</p>
<div class="example">
<pre class="example">&nbsp;{(!#x)+\!#y}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
 0  1
 1  2
 2  3
 3  4
 4  5
 5  6
 6  7
 7  8
 8  9
 9 10
10 11
11 12
12 13
13 14
14 15
15 16
16 17
17 18
18 19
19 20
20 21
..
</pre></div>

<p>Here the code takes each integer from the previous calculation and then add an integer list as long as the send argument to each value.  In order to ensure this is clear one could write something similar and ensure the output is able to be predicted.
</p>
<div class="example">
<pre class="example">&nbsp;{(!x)+\!y}[6;4]
0 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
5 6 7 8
</pre></div>

<p>Now using the matrix above the code indices the first argument and pull substrings that match in length of the search string.
</p>
<div class="example">
<pre class="example">&nbsp;{x@(!#x)+\!#y}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
Fi
in
nd
d 
 t
th
he
e 
 +
++
++
+ 
 n
ne
ee
ed
dl
le
e 
 i
in
..
</pre></div>

<p>At this point one can compare the search substring in this list of substrings to find a match.
</p>
<div class="example">
<pre class="example">&nbsp;{(x@(!#x)+\!#y)~\y}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
000000000110000000000000000001000000b
</pre></div>

<p>And then one can use the where function, <code>&amp;</code>, to determine the index of the matches.
</p>
<div class="example">
<pre class="example">&nbsp;{&amp;(x@(!#x)+\!#y)~\y}[&quot;Find the +++ needle in + the ++ text&quot;;&quot;++&quot;]
9 10 29
</pre></div>

<hr>
<div class="header">
<p>
Next: <a href="Benchmarks.html" accesskey="n" rel="next">Benchmarks</a>, Previous: <a href="Intro.html" accesskey="p" rel="prev">Intro</a>, Up: <a href="index.html" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>



</body>
</html>
